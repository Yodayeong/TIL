## 회원관리 예제 - 백엔드 개발

<br>

#### 비즈니스 요구사항 정리

- 데이터: 회원 ID, 이름
- 기능: 회원 등록, 조회
- 아직 데이터 저장소가 선정되지 않음(가상의 시나리오)

<br>

**일반적인 웹 어플리케이션 계층 구조**

컨트롤러 -> 서비스 -> 리포지토리 -> DB

도메인(컨트롤러, 서비스, 레포지토리와 연결)

- 컨트롤러: 웹 MVC의 컨트롤러 역할
- 서비스: 비즈니스 도메인 객체를 가지고 핵심 비즈니스 로직이 동작하도록 구현한 객체 ex) 회원은 중복 가입이 안됨 ..
- 리포지토리: 데이터베이스에 접근, 도메인 객체를 DB에 저장하고 관리
- 도메인: 비즈니스 도메인 객체 ex) 회원, 주문, 쿠폰 .. 주로 데이터베이스에 저장하고 관리됨

<br>

**클래스 의존 관계**

MemberService -> (interface)MemberRepository <- MemoryMemberRepository

- 아직 데이터 저장소가 선정되지 않아서, 우선 인터페이스로 구현 클래스를 변경할 수 있도록 설계
- 데이터 저장소는 RDB, NoSQL 등등 다양한 저장소를 고민중인 상황으로 가정
- 개발을 진행하기 위해서 초기 개발 단계에서는 구현체로 가벼운 메모리 기반의 데이터 저장소 사용

<br>

#### 회원 도메인과 리포지토리 만들기

- 회원객체 

- `hello.hellospring - package - hello.hellospring.domain`

- `domain - New - Java Calss - Member `

  ```java
  package hello.hellospring.domain;
  
  public class Member {
  
      private Long id; //시스템에 저장을 할 때 시스템이 정해주는 것
      private String name; //고객이 회원가입을 할 때 작성
  
      public Long getId() {
          return id;
      }
  
      public void setId(Long id) {
          this.id = id;
      }
  
      public String getName() {
          return name;
      }
  
      public void setName(String name) {
          this.name = name;
      }
  }
  ```

<br>

- 회원 리포지토리 인터페이스

- `hello.hellospring - package - hello.hellospring.repository`

- `repository - New - Java Class - Interface - MemberRepository`

  ```java
  package hello.hellospring.repository;
  
  import hello.hellospring.domain.Member;
  
  import java.util.List;
  import java.util.Optional;
  
  public interface MemberRepository {
      Member save(Member member); //회원을 저장하면 저장된 회원이 반환됨
      Optional<Member> findById(Long id); //id로 회원을 찾음
      Optional<Member> findByName(String name); //name으로 회원을 찾음
      //이때, id나 name으로 찾았을 때 없으면 null 값이 반환되는데, Optional을 쓰면 Optional로 감싸서 반환함
      List<Member> findall();
  
      //리포지토리의 네가지 기능
      //1. save를 통해 회원을 저장소에 저장
      //2. findById를 통해 회원을 저장소에서 id값으로 찾을 수 있음
      //3. findById를 통해 회원을 저장소에서 name으로 찾을 수 있음
      //4. findAll을 통해 지금까지 저장된 회원 리스트를 모두 반환 할 수 있음
  }
  ```

- 구현체

- `repository - New - Java Class - MemoryMemberRespository`

- MemberRepository를 implements하고, (option + enter) implements methods

  ```java
  package hello.hellospring.repository;
  
  import hello.hellospring.domain.Member;
  
  import java.util.*;
  
  public class MemoryMemberRepository implements MemberRepository {
  
      //save를 할때 저장해줄 곳 (회원 아이디와 값)
      private static Map<Long, Member> store = new HashMap<>();
      //key 값을 생성
      private static long sequence = 0L;
  
      @Override
      public Member save(Member member) {
          member.setId(++sequence);
          store.put(member.getId(), member);
          return member;
      }
  
      @Override
      public Optional<Member> findById(Long id) {
          return Optional.ofNullable(store.get(id)); //값이 null이어도 감쌀 수 있음
      }
  
      @Override
      public Optional<Member> findByName(String name) {
          //람다함수란?
          //익명 함수를 지칭하는 용어 (함수를 보다 단순하게 표현)
          return store.values().stream() //stream: 배열 안에 있는 요소들을 하나씩 참조하며 반복적인 처리를 할 수 있는 것. 원본 데이터의 변경이 없음.
                  .filter(member -> member.getName().equals(name)) //각 멤버의 name이 파라미터로 넘어온 name과 같은지 비교. 같은 경우에만 filter가 됨.
                  .findAny(); //찾으면 반환. 하나를 찾으면 바로 반환. 끝까지 없으면 Optional에 null이 포함되서 반환.
  
      }
  
      @Override
      public List<Member> findall() {
          return new ArrayList<>(store.values()); //store의 values(=members) 반환
      }
  }
  ```

  => 잘 동작하는지 test-case 작성 필요

<br>

#### 회원 리포지토리 테스트 케이스 작성

개발한 기능을 실행해서 테스트 할 때 자바의 main 메서드를 통해서 실행하거나, 웹 어플리케이션의 컨트롤러를 통해서 해당 기능을 실행한다. 이러한 방법은 준비하고 실행하는데 오래 걸리고, 반복 실행하기 어렵고 여러 테스트를 한번에 실행하기 어렵다는 단점이 있다. 자바는 JUnit이라는 프레임워크로 테스트를 실행해서 이러한 문제를 해결한다.

<br>

- 회원 리포지토리 메모리 구현체 테스트

- `test - hello.hellospring - New - package - hello.hellospring.repository`

- `repository - New - Java Class - MemoryMemberRepositoryTest`

  ```java
  package hello.hellospring.repository;
  
  import hello.hellospring.domain.Member;
  import org.assertj.core.api.Assertions;
  import org.junit.jupiter.api.Test;
  
  import java.util.List;
  
  import static org.assertj.core.api.Assertions.*;
  
  //굳이 public으로 할 필요 없음. 다른 곳에서 접근하지 않으므로.
  class MemoryMemberRepositoryTest {
  
      MemberRepository repository = new MemoryMemberRepository();
  
      @Test
      public void save() {
          Member member = new Member();
          member.setName("spring");
  
          repository.save(member);
  
          Member result = repository.findById(member.getId()).get(); //Optional에서 꺼낼 때 get 사용.
  
          //검증 (생성 한 것이랑 result랑 같은지)
          //1. System.out.println("result = " + (result == member)); //결과를 볼 수 있음.
          //2. Assertions.assertEquals(member, null); //jupiter 버전. member가 expected. 성공하면 아무것도 안뜨고, 실패하면 빨간 오류 뜸
          assertThat(member).isEqualTo(result); //assertj 버전. Assertions를 (option + enter)로 static import
      }
  
      @Test
      public void findByName() {
          Member member1 = new Member();
          member1.setName("spring1");
          repository.save(member1);
  
          Member member2 = new Member();
          member2.setName("spring2");
          repository.save(member2);
  
          Member result = repository.findByName("spring1").get();
  
          assertThat(result).isEqualTo(member1); //member2랑 비교하면 오류뜸
      }
  
      @Test
      public void findAll() {
          Member member1 = new Member();
          member1.setName("spring1");
          repository.save(member1);
  
          Member member2 = new Member();
          member2.setName("spring2");
          repository.save(member2);
  
          List<Member> result = repository.findall();
          assertThat(result.size()).isEqualTo(2); //회원 수가 2명
      }
  }
  ```

<br>

- repository 전체 test를 하면 오류가 뜸

- 오류를 보면, findAll이 findByName보다 먼저 실행되는데, findAll은 통과되고 findByName은 통과 안됨

- findByName을 실행할 때, 이전에 저장한 객체가 실행되서 그럼.

- 그래서! test를 끝나고 나면 데이터를 클리어 해줘야함.

- `MemoryMemberRepositoryTest`

  ```java
  class MemoryMemberRepositoryTest {
    
    	MemoryMemberRepository repository = new MemoryMemberRepository(); //MemoryMemberRepository만 테스트 하므로, interface가 아니라 MemoryMemberRepository로 수정
  
      @AfterEach //아래의 메서드들의 실행이 끝날때마다 동작
      public void afterEach() {
          
      }
  }
  ```

- `MemoryMemberRepository`

  ```java
  public class MemoryMemberRepository implements MemberRepository {
  
      public void clearStore() {
          store.clear();
      }
  }
  ```

- `MemoryMemberRepositoryTest`

  ```java
  class MemoryMemberRepositoryTest {
    
    	MemoryMemberRepository repository = new MemoryMemberRepository(); //MemoryMemberRepository만 테스트 하므로, interface가 아니라 MemoryMemberRepository로 수정
  
      @AfterEach //아래의 메서드들의 실행이 끝날때마다 동작
      public void afterEach() {
          repository.clearStore();
      }
  }
  ```

- *테스트는 서로 의존관계 없이 설계 되어야 한다!*

<br>

#### 회원 서비스 개발

회원 리포지토리와 도메인을 활용하여 실제 비즈니스 로직을 구현한다.

<br>

- `hello.hellospring - New - Package - hello.hellospring.service`

- `service - new - Java Class - MemberService`

  ```java
  package hello.hellospring.service;
  
  import hello.hellospring.domain.Member;
  import hello.hellospring.repository.MemberRepository;
  import hello.hellospring.repository.MemoryMemberRepository;
  
  import java.util.Optional;
  
  public class MemberService {
  
      private final MemberRepository memberRepository = new MemoryMemberRepository();
  
      /* 회원가입 */
      public Long join(Member member) {
          //같은 이름이 있는 중복 회원 X
          memberRepository.findByName(member.getName())
                  .ifPresent(m -> {
                      throw new IllegalStateException("이미 존재하는 회원입니다.");
                  });
  
          memberRepository.save(member);
          return member.getId();
      }
  
  }
  ```

- 이때, 중복 회원 검증 부분을 메서드로 추출하고 싶을 때,

- `control + t - Extract Method`

  ```java
  package hello.hellospring.service;
  
  import hello.hellospring.domain.Member;
  import hello.hellospring.repository.MemberRepository;
  import hello.hellospring.repository.MemoryMemberRepository;
  
  import java.util.Optional;
  
  public class MemberService {
  
      private final MemberRepository memberRepository = new MemoryMemberRepository();
  
      /* 회원가입 */
      public Long join(Member member) {
          validateDuplicateMember(member); //중복 회원 검증
          memberRepository.save(member);
          return member.getId();
      }
  
      private void validateDuplicateMember(Member member) {
          memberRepository.findByName(member.getName())
                  .ifPresent(m -> {
                      throw new IllegalStateException("이미 존재하는 회원입니다.");
                  });
      }
  
  }
  ```

- 회원 서비스 부분 전체

  ```java
  package hello.hellospring.service;
  
  import hello.hellospring.domain.Member;
  import hello.hellospring.repository.MemberRepository;
  import hello.hellospring.repository.MemoryMemberRepository;
  
  import java.util.List;
  import java.util.Optional;
  
  public class MemberService {
  
      private final MemberRepository memberRepository = new MemoryMemberRepository();
  
      /* 회원가입 */
      public Long join(Member member) {
          validateDuplicateMember(member); //중복 회원 검증
          memberRepository.save(member);
          return member.getId();
      }
  
      private void validateDuplicateMember(Member member) {
          memberRepository.findByName(member.getName())
                  .ifPresent(m -> {
                      throw new IllegalStateException("이미 존재하는 회원입니다.");
                  });
      }
  
      /* 전체 회원 조회 */
      public List<Member> findMembers() {
          return memberRepository.findall();
      }
  
      /* 회원 조회 */
      public Optional<Member> findOne(Long memberId) {
          return memberRepository.findById(memberId);
      }
  
  }
  ```

<br>

#### 회원 서비스 테스트

앞서 작성한 회원 서비스 클래스를 테스트 해보겠다.

<br>

- 이전처럼 만들어도 되지만,

- `MemberService에서 command + shift + t - Create New Test - 멤버 모두 선택`

- 이때, 테스트 코드는 함수명을 한글로 해도 상관없음

  ```java
  package hello.hellospring.service;
  
  import hello.hellospring.domain.Member;
  import org.assertj.core.api.Assertions;
  import org.junit.jupiter.api.Test;
  
  import java.util.Optional;
  
  import static org.assertj.core.api.AssertionsForClassTypes.assertThat;
  import static org.junit.jupiter.api.Assertions.*;
  
  class MemberServiceTest {
  
      MemberService memberService = new MemberService();
  
      @Test
      void 회원가입() {
          //given: 무엇인가 주어졌는데 (이 데이터를 기반으로)
          Member member = new Member();
          member.setName("hello");
  
          //when: 이것을 실행했을 때 (이것을 검증하는구나)
          Long saveId = memberService.join(member);
  
          //then: 결과가 이것이 나와야 해
          //Optional<Member> one = memberService.findOne(saveId);
          Member findMember = memberService.findOne(saveId).get();
          assertThat(member.getName()).isEqualTo(findMember.getName());
      }
  
      @Test
      public void 중복_회원_예외() {
          //given
          Member member1 = new Member();
          member1.setName("spring");
  
          Member member2 = new Member();
          member2.setName("spring");
  
          //when
          memberService.join(member1);
          IllegalStateException e = assertThrows(IllegalStateException.class, () -> memberService.join(member2)); //뒤쪽 로직을 실행을 하면, 앞쪽 예외가 발생해야한다!
          assertThat(e.getMessage()).isEqualTo("이미 존재하는 회원입니다.");
  
  //        try {
  //            memberService.join(member2);
  //            fail();
  //        } catch (IllegalStateException e) {
  //            assertThat(e.getMessage()).isEqualTo("이미 존재하는 회원입니다.");
  //        }
  
          //then
      }
  
      @Test
      void findMembers() {
      }
  
      @Test
      void findOne() {
      }
  }
  ```

- clear를 해줘야 한다.

  ```java
  class MemberServiceTest {
  
      MemoryMemberRepository memberRepository = new MemoryMemberRepository();
  
      @AfterEach
      public void afterEach() {
          memberRepository.clearStore();
      }
  }
  ```

- 근데 이때, MemberServiceTest의 memberRepository 객체는 MemberService의 MemoryMemberRepository 객체와 다른 객체로 동작

- test 할 때, 같은 repository로 test 하는 것이 좋음 => 같은 인스턴스를 쓰도록 하자

- `MemberService`

  ```java
  public class MemberService {
  
      private final MemberRepository memberRepository;
  
    //constructor -> 외부에서 값을 넣어주도록
      public MemberService(MemberRepository memberRepository) {
          this.memberRepository = memberRepository;
      }
  }
  ```

- `MemberServiceTest`

  ```java
  class MemberServiceTest {
  
      MemberService memberService;
      MemoryMemberRepository memberRepository;
  
    //각 test를 실행하기 전에
    //MemoryMemberRepository를 생성하고,
    //이 repository를 MemberService에 넣어줌.
    //그러면, 같은 MemoryMemberRepository가 사용된다.
      @BeforeEach
      public void beforeEach() {
          memberRepository = new MemoryMemberRepository();
          memberService = new MemberService(memberRepository);
      }
  }
  ```

  