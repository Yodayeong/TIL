## 스프링 DB 접근 기술

<br>

#### H2 데이터베이스 설치

개발이나 테스트 용도로 가볍고 편리한 DB, 웹 화면 제공

- Https://www.h2database.com
- 다운로드 및 설치 (All Platforms)

<br>

- `h2 - bin`에서 터미널 창 열기
- `ls` => h2.sh라는 파일을 볼 수 있다.
- `chmod 755 h2.sh` => 시스템의 모드(권한)을 바꾸는 명령어
- `./h2.sh`
- *혹시 오류가 뜬다면, 앞부분을 지우고 localhost로 수정!*

<br>

- 제일 처음에는 데이터베이스 파일을 만들어야 함 => `jdbc:h2:~/test` => `연결` (최초한번)
- JDBC URL이 파일 경로인데, 홈에 test 폴더가 있는지 확인 (cd로 거슬러올라가서 test.mv.db가 있는지 확인)
- *이후부터는, 파일로 접근하면 파일 충돌이 일어날 수 있으므로 JDBC URL을 수정!* => `jdbc:h2:tcp://localhost/~/test` (소켓을 통한 접근)
- 작업 후, 다시 깔끔하게 정리하고 싶으면 `rm test.mv.db` 후, 다시 앞의 과정 반복

<br>

- 테이블 추가

  ```
  create table member
  (
      id bigint generated by default as identity, //자바에서는 Long 타입이지만, sql에서는 bigint 타입. id값을 세팅하지 않고 insert하면 데이터베이스가 알아서 값을 채우도록 하는 구문.
      name varchar(255), //name의 타입은 varchar로.
      primary key (id) //pk는 id
  );
  ```

  => 왼쪽에 member 테이블이 생성됨

- member 전체 보기

  ```
  select * from member;
  ```

- member 추가하기

  ```
  insert into member(name) values('spring')
  ```

<br>

- 데이터베이스 관리하기

- 제일 상단 hello-spring 폴더에 새로운 디렉토리 만들기 `sql`

- `sql - New - File - ddl.sql`

  ```sql
  drop table if exists member CASCADE;
  create table member
  (
      id bigint generated by default as identity,
      name varchar(255),
      primary key (id)
  );
  ```

<br>

#### 순수 JDBC

- `build.grade`파일 dependencies에 jdbc, h2 데이터베이스 관련 라이브러리 추가 => 코끼리 눌러주기

  ```java
  implementation 'org.springframework.boot:spring-boot-starter-jdbc'
  runtimeOnly 'com.h2database:h2'
  ```

- `src - main - resources - application.properties`

  ```java
  spring.datasource.url=jdbc:h2:tcp://localhost/~/test
  spring.datasource.driver-class-name=org.h2.Driver
  
  spring.datasource.username=sa
  spring.jpa.show-sql=true
  spring.jpa.hibernate.ddl-auto=none
  ```

- `repository - JdbcMemberRepository`

  ```java
  package hello.hellospring.repository;
  import hello.hellospring.domain.Member;
  import org.springframework.jdbc.datasource.DataSourceUtils;
  import javax.sql.DataSource;
  import java.sql.*;
  import java.util.ArrayList;
  import java.util.List;
  import java.util.Optional;
  public class JdbcMemberRepository implements MemberRepository {
      
      private final DataSource dataSource;
      
      public JdbcMemberRepository(DataSource dataSource) {
          this.dataSource = dataSource;
  
      }
      
      @Override
      public Member save(Member member) {
          String sql = "insert into member(name) values(?)";
          Connection conn = null;
          PreparedStatement pstmt = null;
          ResultSet rs = null;
          try {
              conn = getConnection();
              pstmt = conn.prepareStatement(sql,
                      Statement.RETURN_GENERATED_KEYS);
              pstmt.setString(1, member.getName());
              pstmt.executeUpdate();
              rs = pstmt.getGeneratedKeys();
              if (rs.next()) {
                  member.setId(rs.getLong(1));
              } else {
                  throw new SQLException("id 조회 실패");
              }
              return member;
          } catch (Exception e) {
              throw new IllegalStateException(e);
          } finally {
              close(conn, pstmt, rs);
          }
      }
      
      @Override
      public Optional<Member> findById(Long id) {
          String sql = "select * from member where id = ?";
          Connection conn = null;
          PreparedStatement pstmt = null;
  
          ResultSet rs = null;
          try {
              conn = getConnection();
              pstmt = conn.prepareStatement(sql);
              pstmt.setLong(1, id);
              rs = pstmt.executeQuery();
              if(rs.next()) {
                  Member member = new Member();
                  member.setId(rs.getLong("id"));
                  member.setName(rs.getString("name"));
                  return Optional.of(member);
              } else {
                  return Optional.empty();
              }
          } catch (Exception e) {
              throw new IllegalStateException(e);
          } finally {
              close(conn, pstmt, rs);
          } }
      @Override
      public List<Member> findAll() {
          String sql = "select * from member";
          Connection conn = null;
          PreparedStatement pstmt = null;
          ResultSet rs = null;
          try {
              conn = getConnection();
              pstmt = conn.prepareStatement(sql);
              rs = pstmt.executeQuery();
  
              List<Member> members = new ArrayList<>();
              while(rs.next()) {
                  Member member = new Member();
                  member.setId(rs.getLong("id"));
                  member.setName(rs.getString("name"));
                  members.add(member);
              }
              return members;
          } catch (Exception e) {
              throw new IllegalStateException(e);
          } finally {
              close(conn, pstmt, rs);
          }
      }
      
      @Override
      public Optional<Member> findByName(String name) {
          String sql = "select * from member where name = ?";
          Connection conn = null;
          PreparedStatement pstmt = null;
          ResultSet rs = null;
          try {
              conn = getConnection();
              pstmt = conn.prepareStatement(sql);
              pstmt.setString(1, name);
              rs = pstmt.executeQuery();
              if(rs.next()) {
                  Member member = new Member();
                  member.setId(rs.getLong("id"));
                  member.setName(rs.getString("name"));
                  return Optional.of(member);
              }
  
              return Optional.empty();
          } catch (Exception e) {
              throw new IllegalStateException(e);
          } finally {
              close(conn, pstmt, rs);
          }
      }
      
      private Connection getConnection() {
          return DataSourceUtils.getConnection(dataSource);
      }
      
      private void close(Connection conn, PreparedStatement pstmt, ResultSet rs)
      {
          try {
              if (rs != null) {
                  rs.close();
              }
          } catch (SQLException e) {
              e.printStackTrace();
          } try {
          if (pstmt != null) {
              pstmt.close();
          }
      } catch (SQLException e) {
          e.printStackTrace();
      }
          try {
              if (conn != null) {
                  close(conn);
              }
          } catch (SQLException e) {
              e.printStackTrace();
          } }
      private void close(Connection conn) throws SQLException {
          DataSourceUtils.releaseConnection(conn, dataSource);
  
      } }
  ```

- `SpringConfig`

  ```java
  package hello.hellospring;
  
  import hello.hellospring.repository.JdbcMemberRepository;
  import hello.hellospring.repository.MemberRepository;
  import hello.hellospring.repository.MemoryMemberRepository;
  import hello.hellospring.service.MemberService;
  import org.springframework.beans.factory.annotation.Autowired;
  import org.springframework.context.annotation.Bean;
  import org.springframework.context.annotation.Configuration;
  
  import javax.sql.DataSource;
  
  @Configuration
  public class SpringConfig {
      
      private DataSource dataSource;
      
      @Autowired
      public SpringConfig(DataSource dataSource) {
          this.dataSource = dataSource;
      }
  
      @Bean
      public MemberService memberService() {
          return new MemberService(memberRepository());
      }
  
      @Bean
      public MemberRepository memberRepository() {
          
          //return new MemoryMemberRepository();
          return new JdbcMemberRepository(dataSource);
      }
  }
  ```

- memberService 인터페이스에는 `<memory>memberRepository`와 `<jdbc>memberRepository`가 있는데, 이전에는 `<memory>memberRepository`가 구현체로 스프링 빈에 등록되었다면, `<jdbc>memberRepository`를 구현체로 스프링 빈에 등록해주었다.

<br>

#### 스프링 통합 테스트

스프링 컨테이너와 DB까지 연결한 통합 테스트를 진행해보자

- `MemberServiceTest`를 복사 후, `test - service`에 `MemberServiceIntegrationTest`로 붙여넣기

  ```java
  package hello.hellospring.service;
  
  import hello.hellospring.domain.Member;
  import hello.hellospring.repository.MemberRepository;
  import hello.hellospring.repository.MemoryMemberRepository;
  import org.junit.jupiter.api.AfterEach;
  import org.junit.jupiter.api.BeforeEach;
  import org.junit.jupiter.api.Test;
  import org.springframework.beans.factory.annotation.Autowired;
  import org.springframework.boot.test.context.SpringBootTest;
  import org.springframework.transaction.annotation.Transactional;
  
  import static org.assertj.core.api.AssertionsForClassTypes.assertThat;
  import static org.junit.jupiter.api.Assertions.assertThrows;
  
  @SpringBootTest //스프링 컨테이너와 테스트를 함꼐 실행
  @Transactional //테스트 시작 전에 트랜잭션을 시작하고, 테스트 완료 후에 롤백 => 디비에 데이터를 남기지 않으므로, 다음 테스트에 영향 X
  class MemberServiceIntegrationTest {
  
      @Autowired MemberService memberService;
      @Autowired MemberRepository memberRepository;
  
      @Test
      void 회원가입() {
          //given: 무엇인가 주어졌는데 (이 데이터를 기반으로)
          Member member = new Member();
          member.setName("spring");
  
          //when: 이것을 실행했을 때 (이것을 검증하는구나)
          Long saveId = memberService.join(member);
  
          //then: 결과가 이것이 나와야 해
          //Optional<Member> one = memberService.findOne(saveId);
          Member findMember = memberService.findOne(saveId).get();
          assertThat(member.getName()).isEqualTo(findMember.getName());
      }
  
      @Test
      public void 중복_회원_예외() {
          //given
          Member member1 = new Member();
          member1.setName("spring");
  
          Member member2 = new Member();
          member2.setName("spring");
  
          //when
          memberService.join(member1);
          IllegalStateException e = assertThrows(IllegalStateException.class, () -> memberService.join(member2)); //뒤쪽 로직을 실행을 하면, 앞쪽 예외가 발생해야한다!
          assertThat(e.getMessage()).isEqualTo("이미 존재하는 회원입니다.");
  
  //        try {
  //            memberService.join(member2);
  //            fail();
  //        } catch (IllegalStateException e) {
  //            assertThat(e.getMessage()).isEqualTo("이미 존재하는 회원입니다.");
  //        }
  
          //then
      }
  }
  ```

- 회원가입 test를 진행하면 오류가 뜸 => 이미 디비에 spring이란 회원이 등록되어 있어서 => 디비를 정리해줘야함 (보통 테스트 전용 디비를 사용)

  ```sql
  delete from member
  ```

<br>

#### 스프링 JdbcTemplate

- 순수 Jdbc와 동일한 환경설정을 하면 된다.

- 스프링 JdbcTemplate과 MyBatis 같은 라이브러리는 JDBC API에서 본 반복 코드를 대부분 제거해준다. 하지만 SQL은 직접 작성해야 한다.

- `repository - JdbcTemplateMemberRepository`

  ```java
  package hello.hellospring.repository;
  
  import hello.hellospring.domain.Member;
  import org.springframework.beans.factory.annotation.Autowired;
  import org.springframework.jdbc.core.JdbcTemplate;
  import org.springframework.jdbc.core.RowMapper;
  import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
  import org.springframework.jdbc.core.simple.SimpleJdbcInsert;
  
  import javax.sql.DataSource;
  import java.sql.ResultSet;
  import java.sql.SQLException;
  import java.util.HashMap;
  import java.util.List;
  import java.util.Map;
  import java.util.Optional;
  
  public class JdbcTemplateMemberRepository implements MemberRepository {
  
      private final JdbcTemplate jdbcTemplate;
  
      //생성자가 하나면, @Autowired 생략가능
      public JdbcTemplateMemberRepository(DataSource dataSource) {
          jdbcTemplate = new JdbcTemplate(dataSource);
      }
  
      @Override
      public Member save(Member member) {
          SimpleJdbcInsert jdbcInsert = new SimpleJdbcInsert(jdbcTemplate);
          jdbcInsert.withTableName("member").usingGeneratedKeyColumns("id");
  
          Map<String, Object> parameters = new HashMap<>();
          parameters.put("name", member.getName());
  
          Number key = jdbcInsert.executeAndReturnKey(new MapSqlParameterSource(parameters));
          member.setId(key.longValue());
          return member;
      }
  
      @Override
      public Optional<Member> findById(Long id) {
          List<Member> result = jdbcTemplate.query("select * from member where id = ?", memberRowMapper(), id);
          return result.stream().findAny();
      }
  
      @Override
      public Optional<Member> findByName(String name) {
          List<Member> result = jdbcTemplate.query("select * from member where name = ?", memberRowMapper(), name);
          return result.stream().findAny();
      }
  
      @Override
      public List<Member> findAll() {
          return jdbcTemplate.query("select * from member", memberRowMapper());
      }
  
      private RowMapper<Member> memberRowMapper() {
  //        return new RowMapper<Member>() {
  //            @Override
  //            public Member mapRow(ResultSet rs, int rowNum) throws SQLException {
  //                Member member = new Member();
  //                member.setId(rs.getLong("id"));
  //                member.setName(rs.getString("name"));
  //                return member;
  //            }
  //        };
          //이 부분을 람다로 바꿀 수 있음(option + enter)
          return (rs, rowNum) -> {
              Member member = new Member();
              member.setId(rs.getLong("id"));
              member.setName(rs.getString("name"));
              return member;
          };
      }
  }
  ```

- `SpringConfig`

  ```java
  @Configuration
  public class SpringConfig {
  
      private DataSource dataSource;
  
      @Autowired
      public SpringConfig(DataSource dataSource) {
          this.dataSource = dataSource;
      }
  
      @Bean
      public MemberService memberService() {
          return new MemberService(memberRepository());
      }
  
      @Bean
      public MemberRepository memberRepository() {
  
          //return new MemoryMemberRepository();
          //return new JdbcMemberRepository(dataSource);
          return new JdbcTemplateMemberRepository(dataSource);
      }
  }
  ```

<br>

#### JPA

- JPA는 기존의 반복 코드는 물론이고, 기본적인 SQL도 JPA가 직접 만들어서 실행해준다.
- JPA를 사용하면, SQL과 데이터 중심의 설계에서 객체 중심의 설계로 패러다임을 전환할 수 있다.
- JPA를 사용하면 개발 생산성을 크게 높일 수 있다.

<br>

- `build.gradle`파일 dependencies에 JPA 관련 라이브러리 추가 => 코끼리 누르기

  ```java
  //implementation 'org.springframework.boot:spring-boot-starter-jdbc' //jdbc 주석처리하고
  	implementation 'org.springframework.boot:spring-boot-starter-data-jpa' //jpa 라이브러리 추가
  ```

- `application.properties` 

  ```java
  //이 두개를 추가해주면 되는데, 나는 이전에 추가한 적이 있음
  spring.jpa.show-sql=true
  spring.jpa.hibernate.ddl-auto=none
  ```

- `domain - Member`

  ```java
  package hello.hellospring.domain;
  
  import javax.persistence.*;
  
  @Entity //JPA가 관리하는 entity
  public class Member {
  
      @Id @GeneratedValue(strategy = GenerationType.IDENTITY) //pk값인 디비가 Id가 자동으로 생성됨
      private Long id; //시스템에 저장을 할 때 시스템이 정해주는 것
  
  //    @Column(name = "username") //디비의 username과 연결
      private String name; //고객이 회원가입을 할 때 작성
  
      public Long getId() {
          return id;
      }
  
      public void setId(Long id) {
          this.id = id;
      }
  
      public String getName() {
          return name;
      }
  
      public void setName(String name) {
          this.name = name;
      }
  }
  ```

- `repository - JpaMemberRepository`

  ```java
  package hello.hellospring.repository;
  
  import hello.hellospring.domain.Member;
  
  import javax.persistence.EntityManager;
  import java.util.List;
  import java.util.Optional;
  
  public class JpaMemberRepository implements MemberRepository{
  
      private final EntityManager em;
  
      public JpaMemberRepository(EntityManager em) {
          this.em = em;
      }
  
      @Override
      public Member save(Member member) {
          em.persist(member); //persist => 영구 저장
          return member;
      }
  
      @Override
      public Optional<Member> findById(Long id) {
          Member member = em.find(Member.class, id);
          return Optional.ofNullable(member);
      }
  
      @Override
      public Optional<Member> findByName(String name) {
          List<Member> result = em.createQuery("select m from Member m where m.name = :name", Member.class)
                  .setParameter("name", name)
                  .getResultList();
          
          return result.stream().findAny();
      }
  
      @Override
      public List<Member> findAll() {
  //        List<Member> result = em.createQuery("select m from Member m", Member.class)
  //                .getResultList();
  //        return result; 
          
          //(control + t) => inline variable
          return em.createQuery("select m from Member m", Member.class)
                  .getResultList();
      }
  }
  ```

- `MemberService`

  ```java
  @Transactional //transactional 추가
  public class MemberService {
  ...
  }
  ```

- `SpringConfig`

  ```java
  package hello.hellospring;
  
  import hello.hellospring.repository.*;
  import hello.hellospring.service.MemberService;
  import org.springframework.beans.factory.annotation.Autowired;
  import org.springframework.context.annotation.Bean;
  import org.springframework.context.annotation.Configuration;
  
  import javax.persistence.EntityManager;
  import javax.sql.DataSource;
  
  @Configuration
  public class SpringConfig {
  
      private EntityManager em;
  
      @Autowired
      public SpringConfig(EntityManager em) {
          this.em = em;
      }
  
      @Bean
      public MemberService memberService() {
          return new MemberService(memberRepository());
      }
  
      @Bean
      public MemberRepository memberRepository() {
  
          //return new MemoryMemberRepository();
          //return new JdbcMemberRepository(dataSource);
          //return new JdbcTemplateMemberRepository(dataSource);
          return new JpaMemberRepository(em);
      }
  }
  ```

- `MemberServiceIntegrationTest`

  ```java
  package hello.hellospring.service;
  
  import hello.hellospring.domain.Member;
  import hello.hellospring.repository.MemberRepository;
  import hello.hellospring.repository.MemoryMemberRepository;
  import org.junit.jupiter.api.AfterEach;
  import org.junit.jupiter.api.BeforeEach;
  import org.junit.jupiter.api.Test;
  import org.springframework.beans.factory.annotation.Autowired;
  import org.springframework.boot.test.context.SpringBootTest;
  import org.springframework.test.annotation.Commit;
  import org.springframework.transaction.annotation.Transactional;
  
  import static org.assertj.core.api.AssertionsForClassTypes.assertThat;
  import static org.junit.jupiter.api.Assertions.assertThrows;
  
  @SpringBootTest //스프링 컨테이너와 테스트를 함꼐 실행
  @Transactional //테스트 시작 전에 트랜잭션을 시작하고, 테스트 완료 후에 롤백 => 디비에 데이터를 남기지 않으므로, 다음 테스트에 영향 X
  class MemberServiceIntegrationTest {
  
      @Autowired MemberService memberService;
      @Autowired MemberRepository memberRepository;
  
      @Test
      //@Commit => 이 문구를 추가하면 실제로 디비에 추가됨
      void 회원가입() {
          //given: 무엇인가 주어졌는데 (이 데이터를 기반으로)
          Member member = new Member();
          member.setName("spring");
  
          //when: 이것을 실행했을 때 (이것을 검증하는구나)
          Long saveId = memberService.join(member);
  
          //then: 결과가 이것이 나와야 해
          //Optional<Member> one = memberService.findOne(saveId);
          Member findMember = memberService.findOne(saveId).get();
          assertThat(member.getName()).isEqualTo(findMember.getName());
      }
  
      @Test
      public void 중복_회원_예외() {
          //given
          Member member1 = new Member();
          member1.setName("spring");
  
          Member member2 = new Member();
          member2.setName("spring");
  
          //when
          memberService.join(member1);
          IllegalStateException e = assertThrows(IllegalStateException.class, () -> memberService.join(member2)); //뒤쪽 로직을 실행을 하면, 앞쪽 예외가 발생해야한다!
          assertThat(e.getMessage()).isEqualTo("이미 존재하는 회원입니다.");
  
  //        try {
  //            memberService.join(member2);
  //            fail();
  //        } catch (IllegalStateException e) {
  //            assertThat(e.getMessage()).isEqualTo("이미 존재하는 회원입니다.");
  //        }
  
          //then
      }
  }
  ```

<br>

#### 스프링 데이터 JPA

스프링 부트와 JPA만 사용해도 개발 생산성이 정말 많이 증가하고, 개발해야할 코드도 확연히 줄어든다. 여기에 스프링 데이터 JPA를 사용하면, 기존의 한계를 넘어 마치 마법처럼 리포지토리에 구현 클래스 없이 인터페이스 만으로 개발을 완료할 수 있다. 그리고 반복 개발해온 기본 CRUD 기능도 스프링 데이터 JPA가 모두 제공한다.

<br>

- 앞의 JPA 설정을 그대로 사용한다.

- `repository - New - Java Class - Interface - SpringDataJpaMemberRepository`

  ```java
  package hello.hellospring.repository;
  
  import hello.hellospring.domain.Member;
  import org.springframework.data.jpa.repository.JpaRepository;
  
  import java.util.Optional;
  
  public interface SpringDataJpaMemberRepository extends JpaRepository<Member, Long>, MemberRepository{
  
      @Override
      Optional<Member> findByName(String name);
  }
  ```

  => 인터페이스를 구현하면, 스프링 데이터 JPA가 `SpringDataJpaMemberRepository`를 스프링 빈으로 자동 등록해준다.

- `SpringConfig`

  ```java
  package hello.hellospring;
  
  import hello.hellospring.repository.*;
  import hello.hellospring.service.MemberService;
  import org.springframework.beans.factory.annotation.Autowired;
  import org.springframework.context.annotation.Bean;
  import org.springframework.context.annotation.Configuration;
  
  import javax.persistence.EntityManager;
  import javax.sql.DataSource;
  
  @Configuration
  public class SpringConfig {
  
      //인터페이스만 만들어놓으면 구현체를 자동으로 만들어서 등록 => 이 구현체를 주입해서 쓰자!
      private final  MemberRepository memberRepository;
  
      @Autowired //생략가능 => constructor가 하나여서
      public SpringConfig(MemberRepository memberRepository) {
          this.memberRepository = memberRepository;
      }
  
      @Bean
      public MemberService memberService() {
          return new MemberService(memberRepository);
      }
  
  //    @Bean
  //    public MemberRepository memberRepository() {
  //
  //        //return new MemoryMemberRepository();
  //        //return new JdbcMemberRepository(dataSource);
  //        //return new JdbcTemplateMemberRepository(dataSource);
  //        return new JpaMemberRepository(em);
  //
  //    }
  }
  ```

- 스프링 데이터 JPA 제공 기능

- 인터페이스를 통한 기본적인 CRUD

- `findByName()`, `findByEmail()`처럼 메서드 이름 만으로 조회 기능 제공

- 페이징 기능 자동 제공